
// Generated by cppfront v0.8.2 build AA17:1543
#ifndef ISECT_H_CPP2
#define ISECT_H_CPP2

#define CPP2_IMPORT_STD Yes
#define CPP2_NO_EXCEPTIONS Yes

#include "cpp2util.h"

class IntersectionPrim;

class IntersectionQuery;

class Intersection;

class IIntersectable;

#include "ray.h"
#include "vec3.h"

class IntersectionPrim {
private:
  cpp2::i8 _value;

private:
  constexpr IntersectionPrim(cpp2::impl::in<cpp2::i64> _val);

private:
  constexpr auto operator=(cpp2::impl::in<cpp2::i64> _val)
      -> IntersectionPrim &;

public:
  static const IntersectionPrim Unknown;

public:
  static const IntersectionPrim Plane;

public:
  static const IntersectionPrim Sphere;

public:
  [[nodiscard]] constexpr auto get_raw_value() const & -> cpp2::i8;

public:
  constexpr explicit IntersectionPrim();

public:
  constexpr IntersectionPrim(IntersectionPrim const &that);

public:
  constexpr auto operator=(IntersectionPrim const &that) -> IntersectionPrim &;

public:
  constexpr IntersectionPrim(IntersectionPrim &&that) noexcept;

public:
  constexpr auto operator=(IntersectionPrim &&that) noexcept
      -> IntersectionPrim &;

public:
  [[nodiscard]] auto operator<=>(
      IntersectionPrim const &that) const & -> std::strong_ordering = default;

public:
  [[nodiscard]] auto to_string_impl(
      cpp2::impl::in<std::string_view> prefix) const & -> std::string;

public:
  [[nodiscard]] auto to_string() const & -> std::string;

public:
  [[nodiscard]] auto to_code() const & -> std::string;

public:
  [[nodiscard]] static auto from_string(cpp2::impl::in<std::string_view> s)
      -> IntersectionPrim;

public:
  [[nodiscard]] static auto from_code(cpp2::impl::in<std::string_view> s)
      -> IntersectionPrim;
};

class IntersectionQuery {
private:
  cpp2::i8 _value;

private:
  constexpr IntersectionQuery(cpp2::impl::in<cpp2::i64> _val);

private:
  constexpr auto operator=(cpp2::impl::in<cpp2::i64> _val)
      -> IntersectionQuery &;

public:
  static const IntersectionQuery DistanceOnly;

public:
  static const IntersectionQuery Full;

public:
  [[nodiscard]] constexpr auto get_raw_value() const & -> cpp2::i8;

public:
  constexpr explicit IntersectionQuery();

public:
  constexpr IntersectionQuery(IntersectionQuery const &that);

public:
  constexpr auto operator=(IntersectionQuery const &that)
      -> IntersectionQuery &;

public:
  constexpr IntersectionQuery(IntersectionQuery &&that) noexcept;

public:
  constexpr auto operator=(IntersectionQuery &&that) noexcept
      -> IntersectionQuery &;

public:
  [[nodiscard]] auto operator<=>(
      IntersectionQuery const &that) const & -> std::strong_ordering = default;

public:
  [[nodiscard]] auto to_string_impl(
      cpp2::impl::in<std::string_view> prefix) const & -> std::string;

public:
  [[nodiscard]] auto to_string() const & -> std::string;

public:
  [[nodiscard]] auto to_code() const & -> std::string;

public:
  [[nodiscard]] static auto from_string(cpp2::impl::in<std::string_view> s)
      -> IntersectionQuery;

public:
  [[nodiscard]] static auto from_code(cpp2::impl::in<std::string_view> s)
      -> IntersectionQuery;
};

class Intersection {
public:
  Vec3 pos{};

public:
  Vec3 normal{};

public:
  double dist{std::numeric_limits<double>::max()};

public:
  Vec2 uv{};

public:
  IntersectionQuery query{IntersectionQuery::Full};

public:
  IntersectionPrim prim{IntersectionPrim::Unknown};

public:
  auto fromDist(Ray const &r, cpp2::impl::in<double> t) & -> void;

public:
  Intersection(auto &&pos_, auto &&normal_, auto &&dist_, auto &&uv_,
               auto &&query_, auto &&prim_)
      CPP2_REQUIRES_(
          std::is_convertible_v<CPP2_TYPEOF(pos_), std::add_const_t<Vec3> &>
              &&std::is_convertible_v<CPP2_TYPEOF(normal_),
                                      std::add_const_t<Vec3> &>
                  &&std::is_convertible_v<CPP2_TYPEOF(dist_),
                                          std::add_const_t<double> &>
                      &&std::is_convertible_v<CPP2_TYPEOF(uv_),
                                              std::add_const_t<Vec2> &>
                          &&std::is_convertible_v<
                              CPP2_TYPEOF(query_),
                              std::add_const_t<IntersectionQuery> &>
                              &&std::is_convertible_v<
                                  CPP2_TYPEOF(prim_),
                                  std::add_const_t<IntersectionPrim> &>);

public:
  Intersection();
};

class IIntersectable {
public:
  [[nodiscard]] virtual auto intersect(Ray const &r, Intersection &hit) const
      -> bool = 0;

public:
  explicit IIntersectable();

protected:
  IIntersectable([[maybe_unused]] IIntersectable const &that);

protected:
  auto operator=([[maybe_unused]] IIntersectable const &that)
      -> IIntersectable &;

protected:
  IIntersectable([[maybe_unused]] IIntersectable &&that) noexcept;

protected:
  auto operator=([[maybe_unused]] IIntersectable &&that) noexcept
      -> IIntersectable &;

public:
  virtual ~IIntersectable() noexcept;
};

constexpr IntersectionPrim::IntersectionPrim(cpp2::impl::in<cpp2::i64> _val)
    : _value{cpp2::unchecked_narrow<cpp2::i8>(_val)}
{
}

constexpr auto IntersectionPrim::operator=(cpp2::impl::in<cpp2::i64> _val)
    -> IntersectionPrim &
{
  _value = cpp2::unchecked_narrow<cpp2::i8>(_val);
  return *this;
}

inline CPP2_CONSTEXPR IntersectionPrim IntersectionPrim::Unknown{0};

inline CPP2_CONSTEXPR IntersectionPrim IntersectionPrim::Plane{1};

inline CPP2_CONSTEXPR IntersectionPrim IntersectionPrim::Sphere{2};

[[nodiscard]] constexpr auto
IntersectionPrim::get_raw_value() const & -> cpp2::i8
{
  return _value;
}

constexpr IntersectionPrim::IntersectionPrim() : _value{Unknown._value} {}

constexpr IntersectionPrim::IntersectionPrim(IntersectionPrim const &that)
    : _value{that._value}
{
}

constexpr auto IntersectionPrim::operator=(IntersectionPrim const &that)
    -> IntersectionPrim &
{
  _value = that._value;
  return *this;
}

constexpr IntersectionPrim::IntersectionPrim(IntersectionPrim &&that) noexcept
    : _value{std::move(that)._value}
{
}

constexpr auto IntersectionPrim::operator=(IntersectionPrim &&that) noexcept
    -> IntersectionPrim &
{
  _value = std::move(that)._value;
  return *this;
}

[[nodiscard]] auto IntersectionPrim::to_string_impl(
    cpp2::impl::in<std::string_view> prefix) const & -> std::string
{

  auto pref{cpp2::to_string(prefix)};
  if ((*this) == IntersectionPrim::Unknown) {
    return pref + "Unknown";
  }
  if ((*this) == IntersectionPrim::Plane) {
    return pref + "Plane";
  }
  if ((*this) == IntersectionPrim::Sphere) {
    return cpp2::move(pref) + "Sphere";
  }
  return "invalid IntersectionPrim value";
}

[[nodiscard]] auto IntersectionPrim::to_string() const & -> std::string
{
  return to_string_impl("");
}

[[nodiscard]] auto IntersectionPrim::to_code() const & -> std::string
{
  return to_string_impl("IntersectionPrim::");
}

[[nodiscard]] auto
IntersectionPrim::from_string(cpp2::impl::in<std::string_view> s)
    -> IntersectionPrim
{

  auto x{s};
  if ("Unknown" == x) {
    return IntersectionPrim::Unknown;
  } else {
    if ("Plane" == x) {
      return IntersectionPrim::Plane;
    } else {
      if ("Sphere" == cpp2::move(x)) {
        return IntersectionPrim::Sphere;
      }
    }
  }
  CPP2_UFCS(report_violation)(
      cpp2::type_safety,
      CPP2_UFCS(c_str)(("can't convert string '" + cpp2::to_string(s) +
                        "' to enum of type IntersectionPrim")));
  return IntersectionPrim::Unknown;
}

[[nodiscard]] auto
IntersectionPrim::from_code(cpp2::impl::in<std::string_view> s)
    -> IntersectionPrim
{
  std::string str{s};
  return from_string(cpp2::string_util::replace_all(cpp2::move(str),
                                                    "IntersectionPrim::", ""));
}

constexpr IntersectionQuery::IntersectionQuery(cpp2::impl::in<cpp2::i64> _val)
    : _value{cpp2::unchecked_narrow<cpp2::i8>(_val)}
{
}

constexpr auto IntersectionQuery::operator=(cpp2::impl::in<cpp2::i64> _val)
    -> IntersectionQuery &
{
  _value = cpp2::unchecked_narrow<cpp2::i8>(_val);
  return *this;
}

inline CPP2_CONSTEXPR IntersectionQuery IntersectionQuery::DistanceOnly{0};

inline CPP2_CONSTEXPR IntersectionQuery IntersectionQuery::Full{1};

[[nodiscard]] constexpr auto
IntersectionQuery::get_raw_value() const & -> cpp2::i8
{
  return _value;
}

constexpr IntersectionQuery::IntersectionQuery() : _value{DistanceOnly._value}
{
}

constexpr IntersectionQuery::IntersectionQuery(IntersectionQuery const &that)
    : _value{that._value}
{
}

constexpr auto IntersectionQuery::operator=(IntersectionQuery const &that)
    -> IntersectionQuery &
{
  _value = that._value;
  return *this;
}

constexpr IntersectionQuery::IntersectionQuery(
    IntersectionQuery &&that) noexcept
    : _value{std::move(that)._value}
{
}

constexpr auto IntersectionQuery::operator=(IntersectionQuery &&that) noexcept
    -> IntersectionQuery &
{
  _value = std::move(that)._value;
  return *this;
}

[[nodiscard]] auto IntersectionQuery::to_string_impl(
    cpp2::impl::in<std::string_view> prefix) const & -> std::string
{

  auto pref{cpp2::to_string(prefix)};
  if ((*this) == IntersectionQuery::DistanceOnly) {
    return pref + "DistanceOnly";
  }
  if ((*this) == IntersectionQuery::Full) {
    return cpp2::move(pref) + "Full";
  }
  return "invalid IntersectionQuery value";
}

[[nodiscard]] auto IntersectionQuery::to_string() const & -> std::string
{
  return to_string_impl("");
}

[[nodiscard]] auto IntersectionQuery::to_code() const & -> std::string
{
  return to_string_impl("IntersectionQuery::");
}

[[nodiscard]] auto
IntersectionQuery::from_string(cpp2::impl::in<std::string_view> s)
    -> IntersectionQuery
{

  auto x{s};
  if ("DistanceOnly" == x) {
    return IntersectionQuery::DistanceOnly;
  } else {
    if ("Full" == cpp2::move(x)) {
      return IntersectionQuery::Full;
    }
  }
  CPP2_UFCS(report_violation)(
      cpp2::type_safety,
      CPP2_UFCS(c_str)(("can't convert string '" + cpp2::to_string(s) +
                        "' to enum of type IntersectionQuery")));
  return IntersectionQuery::DistanceOnly;
}

[[nodiscard]] auto
IntersectionQuery::from_code(cpp2::impl::in<std::string_view> s)
    -> IntersectionQuery
{
  std::string str{s};
  return from_string(cpp2::string_util::replace_all(cpp2::move(str),
                                                    "IntersectionQuery::", ""));
}

auto Intersection::fromDist(Ray const &r, cpp2::impl::in<double> t) & -> void
{
  pos = CPP2_UFCS(origin)(r) + (CPP2_UFCS(dir)(r) * t);
  dist = t;
}

Intersection::Intersection(auto &&pos_, auto &&normal_, auto &&dist_,
                           auto &&uv_, auto &&query_, auto &&prim_)
  requires(std::is_convertible_v<CPP2_TYPEOF(pos_), std::add_const_t<Vec3> &> &&
           std::is_convertible_v<CPP2_TYPEOF(normal_),
                                 std::add_const_t<Vec3> &> &&
           std::is_convertible_v<CPP2_TYPEOF(dist_),
                                 std::add_const_t<double> &> &&
           std::is_convertible_v<CPP2_TYPEOF(uv_), std::add_const_t<Vec2> &> &&
           std::is_convertible_v<CPP2_TYPEOF(query_),
                                 std::add_const_t<IntersectionQuery> &> &&
           std::is_convertible_v<CPP2_TYPEOF(prim_),
                                 std::add_const_t<IntersectionPrim> &>)
    : pos{CPP2_FORWARD(pos_)}, normal{CPP2_FORWARD(normal_)},
      dist{CPP2_FORWARD(dist_)}, uv{CPP2_FORWARD(uv_)},
      query{CPP2_FORWARD(query_)}, prim{CPP2_FORWARD(prim_)}
{
}

Intersection::Intersection() {}

IIntersectable::IIntersectable() {}

IIntersectable::IIntersectable([[maybe_unused]] IIntersectable const &that) {}

auto IIntersectable::operator=([[maybe_unused]] IIntersectable const &that)
    -> IIntersectable &
{
  return *this;
}

IIntersectable::IIntersectable([[maybe_unused]] IIntersectable &&that) noexcept
{
}

auto IIntersectable::operator=([[maybe_unused]] IIntersectable &&that) noexcept
    -> IIntersectable &
{
  return *this;
}

IIntersectable::~IIntersectable() noexcept {}
#endif
