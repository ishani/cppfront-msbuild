
// Generated by cppfront v0.8.2 build AA17:1543
#ifndef MAT3_H_CPP2
#define MAT3_H_CPP2

#define CPP2_IMPORT_STD Yes
#define CPP2_NO_EXCEPTIONS Yes

#include "cpp2util.h"

class Mat3x3;

#include "geom/vec3.h"

class Mat3x3 {

public:
  Vec3 R0{};

public:
  Vec3 R1{};

public:
  Vec3 R2{};

public:
  Mat3x3(Vec3 const &a, Vec3 const &b, Vec3 const &c);

public:
  [[nodiscard]] auto transform(Vec3 const &vec) const & -> Vec3;

public:
  Mat3x3(Mat3x3 const &that);

public:
  auto operator=(Mat3x3 const &that) -> Mat3x3 &;

public:
  Mat3x3(Mat3x3 &&that) noexcept;

public:
  auto operator=(Mat3x3 &&that) noexcept -> Mat3x3 &;

public:
  explicit Mat3x3();
};

Mat3x3::Mat3x3(Vec3 const &a, Vec3 const &b, Vec3 const &c)
    : R0{a}, R1{b}, R2{c}
{
}

[[nodiscard]] auto Mat3x3::transform(Vec3 const &vec) const & -> Vec3
{
  return Vec3(vec.x * R0.x + vec.y * R1.x + vec.z * R2.x,
              vec.x * R0.y + vec.y * R1.y + vec.z * R2.y,
              vec.x * R0.z + vec.y * R1.z + vec.z * R2.z);
}

Mat3x3::Mat3x3(Mat3x3 const &that) : R0{that.R0}, R1{that.R1}, R2{that.R2} {}

auto Mat3x3::operator=(Mat3x3 const &that) -> Mat3x3 &
{
  R0 = that.R0;
  R1 = that.R1;
  R2 = that.R2;
  return *this;
}

Mat3x3::Mat3x3(Mat3x3 &&that) noexcept
    : R0{std::move(that).R0}, R1{std::move(that).R1}, R2{std::move(that).R2}
{
}

auto Mat3x3::operator=(Mat3x3 &&that) noexcept -> Mat3x3 &
{
  R0 = std::move(that).R0;
  R1 = std::move(that).R1;
  R2 = std::move(that).R2;
  return *this;
}

Mat3x3::Mat3x3() {}
#endif
