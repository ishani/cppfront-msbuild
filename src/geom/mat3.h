
// Generated by cppfront v0.8.2 build AA17:1543
#ifndef MAT3_H_CPP2
#define MAT3_H_CPP2

#define CPP2_IMPORT_STD Yes
#define CPP2_NO_EXCEPTIONS Yes

#include "cpp2util.h"

class Mat3x3;

#include "geom/vec3.h"

class Mat3x3 {

private:
  Vec3 m_R0{};

private:
  Vec3 m_R1{};

private:
  Vec3 m_R2{};

public:
  [[nodiscard]] auto row0() const & -> Vec3;

public:
  [[nodiscard]] auto row1() const & -> Vec3;

public:
  [[nodiscard]] auto row2() const & -> Vec3;

public:
  Mat3x3(Vec3 const &a, Vec3 const &b, Vec3 const &c);

public:
  [[nodiscard]] auto transform(Vec3 const &vec) const & -> Vec3;

public:
  Mat3x3(Mat3x3 const &that);

public:
  auto operator=(Mat3x3 const &that) -> Mat3x3 &;

public:
  Mat3x3(Mat3x3 &&that) noexcept;

public:
  auto operator=(Mat3x3 &&that) noexcept -> Mat3x3 &;

public:
  explicit Mat3x3();
};

[[nodiscard]] auto Mat3x3::row0() const & -> Vec3 { return m_R0; }

[[nodiscard]] auto Mat3x3::row1() const & -> Vec3 { return m_R1; }

[[nodiscard]] auto Mat3x3::row2() const & -> Vec3 { return m_R2; }

Mat3x3::Mat3x3(Vec3 const &a, Vec3 const &b, Vec3 const &c)
    : m_R0{a}, m_R1{b}, m_R2{c}
{
}

[[nodiscard]] auto Mat3x3::transform(Vec3 const &vec) const & -> Vec3
{
  return Vec3(vec.x * m_R0.x + vec.y * m_R1.x + vec.z * m_R2.x,
              vec.x * m_R0.y + vec.y * m_R1.y + vec.z * m_R2.y,
              vec.x * m_R0.z + vec.y * m_R1.z + vec.z * m_R2.z);
}

Mat3x3::Mat3x3(Mat3x3 const &that)
    : m_R0{that.m_R0}, m_R1{that.m_R1}, m_R2{that.m_R2}
{
}

auto Mat3x3::operator=(Mat3x3 const &that) -> Mat3x3 &
{
  m_R0 = that.m_R0;
  m_R1 = that.m_R1;
  m_R2 = that.m_R2;
  return *this;
}

Mat3x3::Mat3x3(Mat3x3 &&that) noexcept
    : m_R0{std::move(that).m_R0}, m_R1{std::move(that).m_R1},
      m_R2{std::move(that).m_R2}
{
}

auto Mat3x3::operator=(Mat3x3 &&that) noexcept -> Mat3x3 &
{
  m_R0 = std::move(that).m_R0;
  m_R1 = std::move(that).m_R1;
  m_R2 = std::move(that).m_R2;
  return *this;
}

Mat3x3::Mat3x3() {}
#endif
