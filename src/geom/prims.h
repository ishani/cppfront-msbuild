
// Generated by cppfront v0.8.2 build AA17:1543
#ifndef PRIMS_H_CPP2
#define PRIMS_H_CPP2

#define CPP2_IMPORT_STD Yes
#define CPP2_NO_EXCEPTIONS Yes

#include "cpp2util.h"

class Sphere;

class Plane;

#include "isect.h"
#include "mat3.h"

class Sphere : public IIntersectable {

private:
  Vec3 m_origin{};

private:
  Vec3 m_align{};

private:
  double m_radius{0};

private:
  Mat3x3 m_alignBasis{};

private:
  double m_radiusSqr{0};

public:
  [[nodiscard]] auto origin() const & -> Vec3;

public:
  [[nodiscard]] auto radius() const & -> double;

public:
  Sphere(Vec3 const &origin, cpp2::impl::in<double> radius, Vec3 const &align);

  // ray intersection; as per Ericson's RTCD book
  // (realtimecollisiondetection.net)
public:
  [[nodiscard]] auto intersect(Ray const &r, Intersection &hit) const
      -> bool final;

public:
  Sphere(Sphere const &that);

public:
  auto operator=(Sphere const &that) -> Sphere &;

public:
  Sphere(Sphere &&that) noexcept;

public:
  auto operator=(Sphere &&that) noexcept -> Sphere &;

public:
  explicit Sphere();
};

class Plane : public IIntersectable {

private:
  Vec3 m_normal{};

private:
  double m_dist{};

public:
  [[nodiscard]] auto normal() const & -> Vec3;

public:
  [[nodiscard]] auto distance() const & -> double;

public:
  Plane(Vec3 const &normal, cpp2::impl::in<double> distance);

public:
  [[nodiscard]] auto intersect(Ray const &r, Intersection &hit) const
      -> bool final;

public:
  Plane(Plane const &that);

public:
  auto operator=(Plane const &that) -> Plane &;

public:
  Plane(Plane &&that) noexcept;

public:
  auto operator=(Plane &&that) noexcept -> Plane &;

public:
  explicit Plane();
};

[[nodiscard]] auto Sphere::origin() const & -> Vec3 { return m_origin; }

[[nodiscard]] auto Sphere::radius() const & -> double { return m_radius; }

Sphere::Sphere(Vec3 const &origin, cpp2::impl::in<double> radius,
               Vec3 const &align)
    : IIntersectable{}, m_origin{origin}, m_radius{radius}
{

  m_align = align;

  m_alignBasis = GetTangentBasisFrisvad(m_align);
  m_radiusSqr = m_radius * m_radius;
}

[[nodiscard]] auto Sphere::intersect(Ray const &r, Intersection &hit) const
    -> bool
{
  auto m{CPP2_UFCS(origin)(r) - origin()};
  auto b{Vec3::dot(m, CPP2_UFCS(dir)(r))};
  auto c{Vec3::dot(m, cpp2::move(m)) - m_radiusSqr};

  // exit if râ€™s origin outside s (c > 0) and r pointing away from s (b > 0)
  if (cpp2::impl::cmp_greater(c, 0.0) && cpp2::impl::cmp_greater(b, 0.0)) {
    return false;
  }

  double discr{b * b - cpp2::move(c)};

  // a negative discriminant corresponds to ray missing sphere
  if (cpp2::impl::cmp_less(discr, 0.0)) {
    return false;
  }

  // write outputs for a successful hit
  hit.prim = IntersectionPrim::Sphere;

  // emit distance along ray; if it is negative, the ray
  // started inside sphere so clamp it to zero
  hit.dist = -cpp2::move(b) - std::sqrt(cpp2::move(discr));
  hit.dist = std::max(hit.dist, 0.0);

  if (hit.query == IntersectionQuery::Full) {
    // compute position and normals
    CPP2_UFCS(fromDist)(hit, r, hit.dist);
    hit.normal = CPP2_UFCS(normalised)((hit.pos - origin()));

    // rotate the normal around the alignment given at construction time and use
    // the result to produce a UV wrap
    auto uvNormal{CPP2_UFCS(transform)(m_alignBasis, hit.normal)};
    hit.uv = {((std::atan2(uvNormal.x, -uvNormal.z) + pi) * recpTwoPi),
              std::acos(uvNormal.y) * recpPi};
  }

  return true;
}

Sphere::Sphere(Sphere const &that)
    : IIntersectable{static_cast<IIntersectable const &>(that)},
      m_origin{that.m_origin}, m_align{that.m_align}, m_radius{that.m_radius},
      m_alignBasis{that.m_alignBasis}, m_radiusSqr{that.m_radiusSqr}
{
}

auto Sphere::operator=(Sphere const &that) -> Sphere &
{
  IIntersectable::operator=(static_cast<IIntersectable const &>(that));
  m_origin = that.m_origin;
  m_align = that.m_align;
  m_radius = that.m_radius;
  m_alignBasis = that.m_alignBasis;
  m_radiusSqr = that.m_radiusSqr;
  return *this;
}

Sphere::Sphere(Sphere &&that) noexcept
    : IIntersectable{static_cast<IIntersectable &&>(that)},
      m_origin{std::move(that).m_origin}, m_align{std::move(that).m_align},
      m_radius{std::move(that).m_radius},
      m_alignBasis{std::move(that).m_alignBasis},
      m_radiusSqr{std::move(that).m_radiusSqr}
{
}

auto Sphere::operator=(Sphere &&that) noexcept -> Sphere &
{
  IIntersectable::operator=(static_cast<IIntersectable &&>(that));
  m_origin = std::move(that).m_origin;
  m_align = std::move(that).m_align;
  m_radius = std::move(that).m_radius;
  m_alignBasis = std::move(that).m_alignBasis;
  m_radiusSqr = std::move(that).m_radiusSqr;
  return *this;
}

Sphere::Sphere() : IIntersectable{} {}

[[nodiscard]] auto Plane::normal() const & -> Vec3 { return m_normal; }

[[nodiscard]] auto Plane::distance() const & -> double { return m_dist; }

Plane::Plane(Vec3 const &normal, cpp2::impl::in<double> distance)
    : IIntersectable{}, m_normal{normal}, m_dist{distance}
{
}

[[nodiscard]] auto Plane::intersect(Ray const &r, Intersection &hit) const
    -> bool
{
  auto d{Vec3::dot(m_normal, CPP2_UFCS(dir)(r))};
  if (d == 0) {
    return false;
  }

  hit.dist =
      -(Vec3::dot(m_normal, CPP2_UFCS(origin)(r)) - m_dist) /
      CPP2_ASSERT_NOT_ZERO(
          CPP2_TYPEOF(-(Vec3::dot(m_normal, CPP2_UFCS(origin)(r)) - m_dist)),
          cpp2::move(d));

  if (cpp2::impl::cmp_greater(hit.dist, 0)) {
    hit.prim = IntersectionPrim::Plane;

    if (hit.query == IntersectionQuery::Full) {
      CPP2_UFCS(fromDist)(hit, r, hit.dist);
      hit.normal = m_normal;

      auto planeBasis{GetTangentBasisFrisvad(m_normal)};
      hit.uv.x = Vec3::dot(CPP2_UFCS(row0)(planeBasis),
                           hit.pos + Vec3(100.0, 0, 100.0));
      hit.uv.y = Vec3::dot(CPP2_UFCS(row1)(cpp2::move(planeBasis)),
                           hit.pos + Vec3(100.0, 0, 100.0));
    }

    return true;
  }

  return false;
}

Plane::Plane(Plane const &that)
    : IIntersectable{static_cast<IIntersectable const &>(that)},
      m_normal{that.m_normal}, m_dist{that.m_dist}
{
}

auto Plane::operator=(Plane const &that) -> Plane &
{
  IIntersectable::operator=(static_cast<IIntersectable const &>(that));
  m_normal = that.m_normal;
  m_dist = that.m_dist;
  return *this;
}

Plane::Plane(Plane &&that) noexcept
    : IIntersectable{static_cast<IIntersectable &&>(that)},
      m_normal{std::move(that).m_normal}, m_dist{std::move(that).m_dist}
{
}

auto Plane::operator=(Plane &&that) noexcept -> Plane &
{
  IIntersectable::operator=(static_cast<IIntersectable &&>(that));
  m_normal = std::move(that).m_normal;
  m_dist = std::move(that).m_dist;
  return *this;
}

Plane::Plane() : IIntersectable{} {}
#endif
