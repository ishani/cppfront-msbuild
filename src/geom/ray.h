
// Generated by cppfront v0.8.2 build AA17:1543
#ifndef RAY_H_CPP2
#define RAY_H_CPP2

#define CPP2_IMPORT_STD Yes
#define CPP2_NO_EXCEPTIONS Yes

#include "cpp2util.h"

class Ray;

class Camera;

#include "mat3.h"
#include "vec2.h"
#include "vec3.h"

#include "math/angle.h"

class Ray {
private:
  Vec3 m_origin{};

private:
  Vec3 m_dir{};

public:
  [[nodiscard]] auto origin() const & -> Vec3;

public:
  [[nodiscard]] auto dir() const & -> Vec3;

public:
  Ray(Vec3 const &origin, Vec3 const &dir);

public:
  Ray(Ray const &that);

public:
  auto operator=(Ray const &that) -> Ray &;

public:
  Ray(Ray &&that) noexcept;

public:
  auto operator=(Ray &&that) noexcept -> Ray &;

public:
  explicit Ray();
};

class Camera {

private:
  Vec3 m_origin{};

private:
  Vec3 m_target{};

private:
  Vec3 m_pdX{};

private:
  Vec3 m_pdY{};

private:
  Vec3 m_pdCenter{};

public:
  [[nodiscard]] auto origin() const & -> Vec3;

public:
  [[nodiscard]] auto target() const & -> Vec3;

public:
  static const Vec3 upVector;

public:
  Camera(Vec3 const &origin, Vec3 const &target,
         cpp2::impl::in<cpp2::u16> frameWidth,
         cpp2::impl::in<cpp2::u16> frameHeight, cpp2::impl::in<Angle> fov);

public:
  [[nodiscard]] auto
  generateRayAtPixelFrac(cpp2::impl::in<double> x,
                         cpp2::impl::in<double> y) const & -> Ray;

public:
  [[nodiscard]] auto
  generateRayAtPixel(cpp2::impl::in<cpp2::u16> x,
                     cpp2::impl::in<cpp2::u16> y) const & -> Ray;

public:
  Camera(Camera const &that);

public:
  auto operator=(Camera const &that) -> Camera &;

public:
  Camera(Camera &&that) noexcept;

public:
  auto operator=(Camera &&that) noexcept -> Camera &;

public:
  explicit Camera();
};

// [Frisvad 2012, "Building an Orthonormal Basis from a 3D Unit Vector Without
// Normalization"]
[[nodiscard]] auto GetTangentBasisFrisvad(Vec3 const &tangentZ) -> Mat3x3;

// generate a random vector in a hemisphere aligned to the input normal
[[nodiscard]] auto RandomHemisphere(Vec3 const &normal, rng32 &rng) -> Vec3;

[[nodiscard]] auto Ray::origin() const & -> Vec3 { return m_origin; }

[[nodiscard]] auto Ray::dir() const & -> Vec3 { return m_dir; }

Ray::Ray(Vec3 const &origin, Vec3 const &dir) : m_origin{origin}, m_dir{dir} {}

Ray::Ray(Ray const &that) : m_origin{that.m_origin}, m_dir{that.m_dir} {}

auto Ray::operator=(Ray const &that) -> Ray &
{
  m_origin = that.m_origin;
  m_dir = that.m_dir;
  return *this;
}

Ray::Ray(Ray &&that) noexcept
    : m_origin{std::move(that).m_origin}, m_dir{std::move(that).m_dir}
{
}

auto Ray::operator=(Ray &&that) noexcept -> Ray &
{
  m_origin = std::move(that).m_origin;
  m_dir = std::move(that).m_dir;
  return *this;
}

Ray::Ray() {}

[[nodiscard]] auto Camera::origin() const & -> Vec3 { return m_origin; }

[[nodiscard]] auto Camera::target() const & -> Vec3 { return m_target; }

inline CPP2_CONSTEXPR Vec3 Camera::upVector{0, 1, 0};

Camera::Camera(Vec3 const &origin, Vec3 const &target,
               cpp2::impl::in<cpp2::u16> frameWidth,
               cpp2::impl::in<cpp2::u16> frameHeight, cpp2::impl::in<Angle> fov)
{

  auto width{cpp2::unchecked_narrow<double>(frameWidth)};
  auto height{cpp2::unchecked_narrow<double>(frameHeight)};
  auto ratio{height / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(height), width)};

  m_origin = origin;
  m_target = target;

  auto camDir{m_target - m_origin};
  auto camDist{CPP2_UFCS(length)(camDir)};

  m_pdX = CPP2_UFCS(normalised)(Vec3::cross(camDir, upVector));
  m_pdY = CPP2_UFCS(normalised)(Vec3::cross(m_pdX, camDir));

  auto FOV{-0.5 * CPP2_UFCS(radians)(fov)};
  auto fX{2.0 * std::tanf(FOV) /
          CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(std::tanf(FOV)), width)};
  auto fY{
      2.0 * std::tanf(cpp2::move(FOV) * cpp2::move(ratio)) /
      CPP2_ASSERT_NOT_ZERO(
          CPP2_TYPEOF(std::tanf(cpp2::move(FOV) * cpp2::move(ratio))), height)};

  m_pdX *= camDist * cpp2::move(fX);
  m_pdY *= cpp2::move(camDist) * cpp2::move(fY);

  m_pdCenter = cpp2::move(camDir) - (m_pdX * (cpp2::move(width) * 0.5)) -
               (m_pdY * (cpp2::move(height) * 0.5));
}

[[nodiscard]] auto
Camera::generateRayAtPixelFrac(cpp2::impl::in<double> x,
                               cpp2::impl::in<double> y) const & -> Ray
{
  auto xV{Vec3(x) * m_pdX + m_pdCenter};
  auto yV{Vec3(y) * m_pdY + cpp2::move(xV)};

  return Ray(m_origin, CPP2_UFCS(normalised)(cpp2::move(yV)));
}

[[nodiscard]] auto
Camera::generateRayAtPixel(cpp2::impl::in<cpp2::u16> x,
                           cpp2::impl::in<cpp2::u16> y) const & -> Ray
{
  auto xD{cpp2::unchecked_narrow<double>(x)};
  auto yD{cpp2::unchecked_narrow<double>(y)};

  return generateRayAtPixelFrac(cpp2::move(xD), cpp2::move(yD));
}

Camera::Camera(Camera const &that)
    : m_origin{that.m_origin}, m_target{that.m_target}, m_pdX{that.m_pdX},
      m_pdY{that.m_pdY}, m_pdCenter{that.m_pdCenter}
{
}

auto Camera::operator=(Camera const &that) -> Camera &
{
  m_origin = that.m_origin;
  m_target = that.m_target;
  m_pdX = that.m_pdX;
  m_pdY = that.m_pdY;
  m_pdCenter = that.m_pdCenter;
  return *this;
}

Camera::Camera(Camera &&that) noexcept
    : m_origin{std::move(that).m_origin}, m_target{std::move(that).m_target},
      m_pdX{std::move(that).m_pdX}, m_pdY{std::move(that).m_pdY},
      m_pdCenter{std::move(that).m_pdCenter}
{
}

auto Camera::operator=(Camera &&that) noexcept -> Camera &
{
  m_origin = std::move(that).m_origin;
  m_target = std::move(that).m_target;
  m_pdX = std::move(that).m_pdX;
  m_pdY = std::move(that).m_pdY;
  m_pdCenter = std::move(that).m_pdCenter;
  return *this;
}

Camera::Camera() {}

[[nodiscard]] auto GetTangentBasisFrisvad(Vec3 const &tangentZ) -> Mat3x3
{

  Vec3 tangentX{};
  Vec3 tangentY{};

  if ((cpp2::impl::cmp_less(tangentZ.z, -0.9999999))) {
    tangentX = Vec3(0, -1, 0);
    tangentY = Vec3(-1, 0, 0);
  } else {
    auto A{1.0 / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(1.0), (1.0 + tangentZ.z))};
    auto B{-tangentZ.x * tangentZ.y * A};
    tangentX = Vec3(1.0 - tangentZ.x * tangentZ.x * A, B, -tangentZ.x);
    tangentY = Vec3(cpp2::move(B),
                    1.0 - tangentZ.y * tangentZ.y * cpp2::move(A), -tangentZ.y);
  }

  return Mat3x3(cpp2::move(tangentX), cpp2::move(tangentY), tangentZ);
}

[[nodiscard]] auto RandomHemisphere(Vec3 const &normal, rng32 &rng) -> Vec3
{

  auto randX{CPP2_UFCS(genFloat)(rng)};
  auto randY{CPP2_UFCS(genFloat)(rng)};

  auto basis{GetTangentBasisFrisvad(normal)};
  auto constexpr hemiUp{Vec3(0, 0, 1)};

  auto uu{Vec3::cross(hemiUp, Vec3(1.0, 0.0, 0.0))};
  auto vv{Vec3::cross(uu, hemiUp)};
  auto ra{std::sqrt(randY)};

  // could turn this into a big LUT to save hammering sin/cos
  auto rx{ra * std::cos(twoPi * randX)};
  auto ry{cpp2::move(ra) * std::sin(twoPi * cpp2::move(randX))};
  auto rz{std::sqrt(1.0 - cpp2::move(randY))};

  auto hemiDir{(cpp2::move(uu) * cpp2::move(rx)) +
               (cpp2::move(vv) * cpp2::move(ry)) + (hemiUp * cpp2::move(rz))};
  auto basisDir{CPP2_UFCS(transform)(
      cpp2::move(basis), CPP2_UFCS(normalised)(cpp2::move(hemiDir)))};

  return basisDir;
}
#endif
