
// Generated by cppfront v0.8.2 build AA17:1543
#ifndef VEC3_H_CPP2
#define VEC3_H_CPP2

#define CPP2_IMPORT_STD Yes
#define CPP2_NO_EXCEPTIONS Yes

#include "cpp2util.h"

class Vec3;

#include "math/rng.h"

class Vec3 {

public:
  double x{0.0};

public:
  double y{0.0};

public:
  double z{0.0};

public:
  constexpr Vec3(cpp2::impl::in<double> _x, cpp2::impl::in<double> _y,
                 cpp2::impl::in<double> _z);

public:
  constexpr Vec3(cpp2::impl::in<double> _all);

public:
  constexpr auto operator=(cpp2::impl::in<double> _all) -> Vec3 &;

public:
  [[nodiscard]] auto format() const & -> std::string;

public:
  [[nodiscard]] auto reciprocal() const & -> Vec3;

public:
  [[nodiscard]] static auto cross(Vec3 const &lhs, Vec3 const &rhs) -> Vec3;

public:
  Vec3(Vec3 const &that);

public:
  auto operator=(Vec3 const &that) -> Vec3 &;

public:
  Vec3(Vec3 &&that) noexcept;

public:
  auto operator=(Vec3 &&that) noexcept -> Vec3 &;

public:
  explicit Vec3();

public:
  [[nodiscard]] auto lengthSquared() const & -> auto;

public:
  [[nodiscard]] auto length() const & -> auto;

public:
  auto normalise() & -> void;

public:
  [[nodiscard]] auto normalised() const & -> Vec3;

public:
  [[nodiscard]] static auto dot(Vec3 const &lhs, Vec3 const &rhs) -> auto;

public:
  [[nodiscard]] auto operator+(Vec3 const &other) const & -> Vec3;

public:
  [[nodiscard]] auto operator-(Vec3 const &other) const & -> Vec3;

public:
  [[nodiscard]] auto operator*(Vec3 const &other) const & -> Vec3;

public:
  [[nodiscard]] auto operator/(Vec3 const &other) const & -> Vec3;

public:
  [[nodiscard]] auto operator-() const & -> Vec3;

public:
  auto operator+=(Vec3 const &other) & -> void;

public:
  auto operator-=(Vec3 const &other) & -> void;

public:
  auto operator*=(Vec3 const &other) & -> void;

public:
  auto operator/=(Vec3 const &other) & -> void;

public:
  [[nodiscard]] auto operator+(cpp2::impl::in<double> other) const & -> Vec3;

public:
  [[nodiscard]] auto operator-(cpp2::impl::in<double> other) const & -> Vec3;

public:
  [[nodiscard]] auto operator*(cpp2::impl::in<double> other) const & -> Vec3;

public:
  [[nodiscard]] auto operator/(cpp2::impl::in<double> other) const & -> Vec3;

public:
  auto operator+=(cpp2::impl::in<double> other) & -> void;

public:
  auto operator-=(cpp2::impl::in<double> other) & -> void;

public:
  auto operator*=(cpp2::impl::in<double> other) & -> void;

public:
  auto operator/=(cpp2::impl::in<double> other) & -> void;
};

[[nodiscard]] auto RandomNormal(rng32 &rng) -> Vec3;

constexpr Vec3::Vec3(cpp2::impl::in<double> _x, cpp2::impl::in<double> _y,
                     cpp2::impl::in<double> _z)
    : x{_x}, y{_y}, z{_z}
{
}

constexpr Vec3::Vec3(cpp2::impl::in<double> _all) : x{_all}, y{_all}, z{_all} {}

constexpr auto Vec3::operator=(cpp2::impl::in<double> _all) -> Vec3 &
{
  x = _all;
  y = _all;
  z = _all;
  return *this;
}

[[nodiscard]] auto Vec3::format() const & -> std::string
{
  return std::format("[{}, {}, {}]", x, y, z);
}

[[nodiscard]] auto Vec3::reciprocal() const & -> Vec3
{
  return Vec3(1.0 / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(1.0), x),
              1.0 / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(1.0), y),
              1.0 / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(1.0), z));
}

[[nodiscard]] auto Vec3::cross(Vec3 const &lhs, Vec3 const &rhs) -> Vec3
{
  return Vec3(lhs.y * rhs.z - lhs.z * rhs.y, lhs.z * rhs.x - lhs.x * rhs.z,
              lhs.x * rhs.y - lhs.y * rhs.x);
}

Vec3::Vec3(Vec3 const &that) : x{that.x}, y{that.y}, z{that.z} {}

auto Vec3::operator=(Vec3 const &that) -> Vec3 &
{
  x = that.x;
  y = that.y;
  z = that.z;
  return *this;
}

Vec3::Vec3(Vec3 &&that) noexcept
    : x{std::move(that).x}, y{std::move(that).y}, z{std::move(that).z}
{
}

auto Vec3::operator=(Vec3 &&that) noexcept -> Vec3 &
{
  x = std::move(that).x;
  y = std::move(that).y;
  z = std::move(that).z;
  return *this;
}

Vec3::Vec3() {}

[[nodiscard]] auto Vec3::lengthSquared() const & -> auto
{
  return (x * x) + (y * y) + (z * z);
}

[[nodiscard]] auto Vec3::length() const & -> auto
{
  return std::sqrt(lengthSquared());
}

auto Vec3::normalise() & -> void
{

  auto len{length()};
  x /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(x), len);
  y /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(y), len);
  z /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(z), cpp2::move(len));
}

[[nodiscard]] auto Vec3::normalised() const & -> Vec3
{

  auto len{length()};
  return Vec3(x / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(x), len),
              y / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(y), len),
              z / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(z), len));
}

[[nodiscard]] auto Vec3::dot(Vec3 const &lhs, Vec3 const &rhs) -> auto
{
  return (lhs.x * rhs.x) + (lhs.y * rhs.y) + (lhs.z * rhs.z);
}

[[nodiscard]] auto Vec3::operator+(Vec3 const &other) const & -> Vec3
{
  return Vec3(x + other.x, y + other.y, z + other.z);
}

[[nodiscard]] auto Vec3::operator-(Vec3 const &other) const & -> Vec3
{
  return Vec3(x - other.x, y - other.y, z - other.z);
}

[[nodiscard]] auto Vec3::operator*(Vec3 const &other) const & -> Vec3
{
  return Vec3(x * other.x, y * other.y, z * other.z);
}

[[nodiscard]] auto Vec3::operator/(Vec3 const &other) const & -> Vec3
{
  return Vec3(x / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(x), other.x),
              y / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(y), other.y),
              z / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(z), other.z));
}

[[nodiscard]] auto Vec3::operator-() const & -> Vec3
{
  return Vec3(-x, -y, -z);
}

auto Vec3::operator+=(Vec3 const &other) & -> void
{
  x += other.x;
  y += other.y;
  z += other.z;
}

auto Vec3::operator-=(Vec3 const &other) & -> void
{
  x -= other.x;
  y -= other.y;
  z -= other.z;
}

auto Vec3::operator*=(Vec3 const &other) & -> void
{
  x *= other.x;
  y *= other.y;
  z *= other.z;
}

auto Vec3::operator/=(Vec3 const &other) & -> void
{
  x /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(x), other.x);
  y /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(y), other.y);
  z /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(z), other.z);
}

[[nodiscard]] auto Vec3::operator+(cpp2::impl::in<double> other) const & -> Vec3
{
  return Vec3(x + other, y + other, z + other);
}

[[nodiscard]] auto Vec3::operator-(cpp2::impl::in<double> other) const & -> Vec3
{
  return Vec3(x - other, y - other, z - other);
}

[[nodiscard]] auto Vec3::operator*(cpp2::impl::in<double> other) const & -> Vec3
{
  return Vec3(x * other, y * other, z * other);
}

[[nodiscard]] auto Vec3::operator/(cpp2::impl::in<double> other) const & -> Vec3
{
  return Vec3(x / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(x), other),
              y / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(y), other),
              z / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(z), other));
}

auto Vec3::operator+=(cpp2::impl::in<double> other) & -> void
{
  x += other;
  y += other;
  z += other;
}

auto Vec3::operator-=(cpp2::impl::in<double> other) & -> void
{
  x -= other;
  y -= other;
  z -= other;
}

auto Vec3::operator*=(cpp2::impl::in<double> other) & -> void
{
  x *= other;
  y *= other;
  z *= other;
}

auto Vec3::operator/=(cpp2::impl::in<double> other) & -> void
{
  x /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(x), other);
  y /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(y), other);
  z /= CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(z), other);
}

[[nodiscard]] auto RandomNormal(rng32 &rng) -> Vec3
{
  auto rX{-1.0 + (CPP2_UFCS(genFloat)(rng) * 2.0)};
  auto rY{-1.0 + (CPP2_UFCS(genFloat)(rng) * 2.0)};
  auto rZ{-1.0 + (CPP2_UFCS(genFloat)(rng) * 2.0)};

  return CPP2_UFCS(normalised)(
      Vec3(cpp2::move(rX), cpp2::move(rY), cpp2::move(rZ)));
}
#endif
