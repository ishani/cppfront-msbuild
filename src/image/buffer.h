
// Generated by cppfront v0.8.2 build AA17:1543
#ifndef BUFFER_H_CPP2
#define BUFFER_H_CPP2

#define CPP2_IMPORT_STD Yes
#define CPP2_NO_EXCEPTIONS Yes

#include "cpp2util.h"

class ColourF;

class ColourU8;

template <typename T> class IBuffer;

template <cpp2::u16 width, cpp2::u16 height> class BufferRGB;

#include "geom/vec2.h"

[[nodiscard]] auto TonemapACES(cpp2::impl::in<double> t) -> cpp2::u8;

class ColourF {
public:
  double r{0};

public:
  double g{0};

public:
  double b{0};

public:
  [[nodiscard]] auto tonemap() const & -> ColourU8;

public:
  ColourF(auto &&r_, auto &&g_, auto &&b_) CPP2_REQUIRES_(
      std::is_convertible_v<CPP2_TYPEOF(r_), std::add_const_t<double> &>
          &&std::is_convertible_v<CPP2_TYPEOF(g_), std::add_const_t<double> &>
              &&std::is_convertible_v<CPP2_TYPEOF(b_),
                                      std::add_const_t<double> &>);

public:
  ColourF();
};

class ColourU8 {
public:
  cpp2::u8 r{0};

public:
  cpp2::u8 g{0};

public:
  cpp2::u8 b{0};

public:
  ColourU8(auto &&r_, auto &&g_, auto &&b_) CPP2_REQUIRES_(
      std::is_convertible_v<CPP2_TYPEOF(r_), std::add_const_t<cpp2::u8> &>
          &&std::is_convertible_v<CPP2_TYPEOF(g_), std::add_const_t<cpp2::u8> &>
              &&std::is_convertible_v<CPP2_TYPEOF(b_),
                                      std::add_const_t<cpp2::u8> &>);

public:
  ColourU8();
};

template <typename T> class IBuffer {
public:
  [[nodiscard]] virtual auto getWidth() const -> cpp2::u16 = 0;

public:
  [[nodiscard]] virtual auto getHeight() const -> cpp2::u16 = 0;

public:
  [[nodiscard]] virtual auto getUVatXY(cpp2::impl::in<cpp2::u16> x,
                                       cpp2::impl::in<cpp2::u16> y) const
      -> Vec2 = 0;

public:
  [[nodiscard]] virtual auto get(cpp2::impl::in<cpp2::u16> x,
                                 cpp2::impl::in<cpp2::u16> y) const
      -> T const & = 0;

public:
  virtual auto set(cpp2::impl::in<cpp2::u16> x, cpp2::impl::in<cpp2::u16> y,
                   T const &pixel) -> void = 0;

public:
  explicit IBuffer();

protected:
  IBuffer([[maybe_unused]] IBuffer const &that);

protected:
  auto operator=([[maybe_unused]] IBuffer const &that) -> IBuffer &;

protected:
  IBuffer([[maybe_unused]] IBuffer &&that) noexcept;

protected:
  auto operator=([[maybe_unused]] IBuffer &&that) noexcept -> IBuffer &;

public:
  virtual ~IBuffer() noexcept;
};

using IColourBufferPtr = std::shared_ptr<IBuffer<ColourF>>;

template <cpp2::u16 width, cpp2::u16 height>
class BufferRGB : public IBuffer<ColourF> {
  // implement IBuffer

public:
  [[nodiscard]] auto getWidth() const -> cpp2::u16 final;

public:
  [[nodiscard]] auto getHeight() const -> cpp2::u16 final;

private:
  static const Vec2 recp;

public:
  [[nodiscard]] auto getUVatXY(cpp2::impl::in<cpp2::u16> x,
                               cpp2::impl::in<cpp2::u16> y) const -> Vec2 final;

public:
  [[nodiscard]] constexpr auto getAspectRatio() const & -> double;

  // fixed storage of RGB data as floats
private:
  std::array<ColourF, width * height> data{};

  // get offset into [data] for the given pixel coordinate
private:
  [[nodiscard]] constexpr auto
  offset(cpp2::impl::in<cpp2::u16> x,
         cpp2::impl::in<cpp2::u16> y) const & -> size_t;

public:
  [[nodiscard]] auto get(cpp2::impl::in<cpp2::u16> x,
                         cpp2::impl::in<cpp2::u16> y) const
      -> ColourF const & final;

public:
  auto set(cpp2::impl::in<cpp2::u16> x, cpp2::impl::in<cpp2::u16> y,
           ColourF const &pixel) -> void final;

public:
  BufferRGB() = default;

public:
  BufferRGB(BufferRGB const &) =
      delete; /* No 'that' constructor, suppress copy */
public:
  auto operator=(BufferRGB const &) -> void = delete;
};

[[nodiscard]] auto TonemapACES(cpp2::impl::in<double> t) -> cpp2::u8
{
  double constexpr a{2.51};
  double constexpr b{0.03};
  double constexpr c{2.43};
  double constexpr d{0.59};
  double constexpr e{0.14};

  auto clip{std::clamp((t * (a * t + b)) /
                           CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF((t * (a * t + b))),
                                                (t * (c * t + d) + e)),
                       0.0, 1.0)};

  return cpp2::unchecked_narrow<cpp2::u8>(cpp2::move(clip) * 255.0);
}

[[nodiscard]] auto ColourF::tonemap() const & -> ColourU8
{
  return ColourU8(TonemapACES(std::max(r, 0.0)), TonemapACES(std::max(g, 0.0)),
                  TonemapACES(std::max(b, 0.0)));
}

ColourF::ColourF(auto &&r_, auto &&g_, auto &&b_)
  requires(std::is_convertible_v<CPP2_TYPEOF(r_), std::add_const_t<double> &> &&
           std::is_convertible_v<CPP2_TYPEOF(g_), std::add_const_t<double> &> &&
           std::is_convertible_v<CPP2_TYPEOF(b_), std::add_const_t<double> &>)
    : r{CPP2_FORWARD(r_)}, g{CPP2_FORWARD(g_)}, b{CPP2_FORWARD(b_)}
{
}

ColourF::ColourF() {}

ColourU8::ColourU8(auto &&r_, auto &&g_, auto &&b_)
  requires(std::is_convertible_v<CPP2_TYPEOF(r_),
                                 std::add_const_t<cpp2::u8> &> &&
           std::is_convertible_v<CPP2_TYPEOF(g_),
                                 std::add_const_t<cpp2::u8> &> &&
           std::is_convertible_v<CPP2_TYPEOF(b_), std::add_const_t<cpp2::u8> &>)
    : r{CPP2_FORWARD(r_)}, g{CPP2_FORWARD(g_)}, b{CPP2_FORWARD(b_)}
{
}

ColourU8::ColourU8() {}

template <typename T> IBuffer<T>::IBuffer() {}

template <typename T> IBuffer<T>::IBuffer([[maybe_unused]] IBuffer const &that)
{
}

template <typename T>
auto IBuffer<T>::operator=([[maybe_unused]] IBuffer const &that) -> IBuffer &
{
  return *this;
}

template <typename T>
IBuffer<T>::IBuffer([[maybe_unused]] IBuffer &&that) noexcept
{
}

template <typename T>
auto IBuffer<T>::operator=([[maybe_unused]] IBuffer &&that) noexcept
    -> IBuffer &
{
  return *this;
}

template <typename T> IBuffer<T>::~IBuffer() noexcept {}

template <cpp2::u16 width, cpp2::u16 height>
[[nodiscard]] auto BufferRGB<width, height>::getWidth() const -> cpp2::u16
{
  return width;
}

template <cpp2::u16 width, cpp2::u16 height>
[[nodiscard]] auto BufferRGB<width, height>::getHeight() const -> cpp2::u16
{
  return height;
}

template <cpp2::u16 width, cpp2::u16 height>
inline CPP2_CONSTEXPR Vec2 BufferRGB<width, height>::recp{
    1.0 / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(1.0), width),
    1.0 / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(1.0), height)};

template <cpp2::u16 width, cpp2::u16 height>
[[nodiscard]] auto
BufferRGB<width, height>::getUVatXY(cpp2::impl::in<cpp2::u16> x,
                                    cpp2::impl::in<cpp2::u16> y) const -> Vec2
{
  Vec2 xy2{cpp2::unchecked_narrow<double>(x),
           cpp2::unchecked_narrow<double>(y)};
  return cpp2::move(xy2) * recp;
}

template <cpp2::u16 width, cpp2::u16 height>
[[nodiscard]] constexpr auto
BufferRGB<width, height>::getAspectRatio() const & -> double
{
  return cpp2::unchecked_narrow<double>(width) /
         CPP2_ASSERT_NOT_ZERO(
             CPP2_TYPEOF(cpp2::unchecked_narrow<double>(width)),
             cpp2::unchecked_narrow<double>(height));
}

template <cpp2::u16 width, cpp2::u16 height>
[[nodiscard]] constexpr auto
BufferRGB<width, height>::offset(cpp2::impl::in<cpp2::u16> x,
                                 cpp2::impl::in<cpp2::u16> y) const & -> size_t
{
  return (y * width) + x;
}

template <cpp2::u16 width, cpp2::u16 height>
[[nodiscard]] auto
BufferRGB<width, height>::get(cpp2::impl::in<cpp2::u16> x,
                              cpp2::impl::in<cpp2::u16> y) const
    -> ColourF const &

{
  if (cpp2::bounds_safety.is_active() && !(cpp2::impl::cmp_less(x, width))) {
    cpp2::bounds_safety.report_violation(CPP2_CONTRACT_MSG(
        "x=" + cpp2::to_string(x) +
        ", larger than width=" + cpp2::to_string(width) + ""));
  }
  if (cpp2::bounds_safety.is_active() && !(cpp2::impl::cmp_less(y, height))) {
    cpp2::bounds_safety.report_violation(CPP2_CONTRACT_MSG(
        "y=" + cpp2::to_string(y) +
        ", larger than height=" + cpp2::to_string(height) + ""));
  }
  return cpp2::unchecked_subscript(data, offset(x, y));
}

template <cpp2::u16 width, cpp2::u16 height>
auto BufferRGB<width, height>::set(cpp2::impl::in<cpp2::u16> x,
                                   cpp2::impl::in<cpp2::u16> y,
                                   ColourF const &pixel) -> void

{
  if (cpp2::bounds_safety.is_active() && !(cpp2::impl::cmp_less(x, width))) {
    cpp2::bounds_safety.report_violation(CPP2_CONTRACT_MSG(
        "x=" + cpp2::to_string(x) +
        ", larger than width=" + cpp2::to_string(width) + ""));
  }
  if (cpp2::bounds_safety.is_active() && !(cpp2::impl::cmp_less(y, height))) {
    cpp2::bounds_safety.report_violation(CPP2_CONTRACT_MSG(
        "y=" + cpp2::to_string(y) +
        ", larger than height=" + cpp2::to_string(height) + ""));
  }
  cpp2::unchecked_subscript(data, offset(x, y)) = pixel;
}
#endif
