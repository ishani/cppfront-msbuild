
// Generated by cppfront v0.8.2 build AA17:1543
#ifndef TGA_H_CPP2
#define TGA_H_CPP2

#define CPP2_IMPORT_STD Yes
#define CPP2_NO_EXCEPTIONS Yes

#include "cpp2util.h"

namespace detail {

class TGAImageType;

class TGAHeader;

} // namespace detail

#include "util/scope.h"

// ---------------------------------------------------------------------------------------------------------------------
// absolutely bare-bones TGA format support for writing out an uncompressed
// 24-bit BGR image

#pragma pack(push, 1)

namespace detail {

class TGAImageType {
private:
  cpp2::u8 _value;

private:
  constexpr TGAImageType(cpp2::impl::in<cpp2::i64> _val);

private:
  constexpr auto operator=(cpp2::impl::in<cpp2::i64> _val) -> TGAImageType &;

public:
  static const TGAImageType NoImage;

public:
  static const TGAImageType UncompressedRgb;

public:
  [[nodiscard]] constexpr auto get_raw_value() const & -> cpp2::u8;

public:
  constexpr explicit TGAImageType();

public:
  constexpr TGAImageType(TGAImageType const &that);

public:
  constexpr auto operator=(TGAImageType const &that) -> TGAImageType &;

public:
  constexpr TGAImageType(TGAImageType &&that) noexcept;

public:
  constexpr auto operator=(TGAImageType &&that) noexcept -> TGAImageType &;

public:
  [[nodiscard]] auto operator<=>(
      TGAImageType const &that) const & -> std::strong_ordering = default;

public:
  [[nodiscard]] auto to_string_impl(
      cpp2::impl::in<std::string_view> prefix) const & -> std::string;

public:
  [[nodiscard]] auto to_string() const & -> std::string;

public:
  [[nodiscard]] auto to_code() const & -> std::string;

public:
  [[nodiscard]] static auto from_string(cpp2::impl::in<std::string_view> s)
      -> TGAImageType;

public:
  [[nodiscard]] static auto from_code(cpp2::impl::in<std::string_view> s)
      -> TGAImageType;
};

class TGAHeader {
private:
  cpp2::u8 idLength{0};

private:
  cpp2::u8 ColourFMapType{0};

private:
  TGAImageType imageType{TGAImageType::UncompressedRgb};

private:
  cpp2::u16 ColourFMapOrigin{0};

private:
  cpp2::u16 ColourFMapLength{0};

private:
  cpp2::u8 ColourFMapDepth{0};

private:
  cpp2::u16 imageXOrigin{0};

private:
  cpp2::u16 imageYOrigin{0};

private:
  cpp2::u16 imageWidth{0};

private:
  cpp2::u16 imageHeight{0};

private:
  cpp2::u8 imageBitsPP{24};

private:
  cpp2::u8 imageDesc{1 << 5}; // set origin to be top-left corner

public:
  TGAHeader(cpp2::impl::in<cpp2::u16> width, cpp2::impl::in<cpp2::u16> height);

public:
  [[nodiscard]] auto getWidth() const & -> cpp2::u16;

public:
  [[nodiscard]] auto getHeight() const & -> cpp2::u16;

public:
  [[nodiscard]] auto
  operator<=>(TGAHeader const &that) const & -> std::strong_ordering = default;

public:
  TGAHeader(TGAHeader const &that);

public:
  auto operator=(TGAHeader const &that) -> TGAHeader &;

public:
  TGAHeader(TGAHeader &&that) noexcept;

public:
  auto operator=(TGAHeader &&that) noexcept -> TGAHeader &;

public:
  explicit TGAHeader();
};

} // namespace detail

#pragma pack(pop)

// ---------------------------------------------------------------------------------------------------------------------
[[nodiscard]] auto
WriteBufferAsTGA(cpp2::impl::in<IColourBufferPtr> image,
                 cpp2::impl::in<std::filesystem::path> filename) -> bool;

namespace detail {

constexpr TGAImageType::TGAImageType(cpp2::impl::in<cpp2::i64> _val)
    : _value{cpp2::unchecked_narrow<cpp2::u8>(_val)}
{
}

constexpr auto TGAImageType::operator=(cpp2::impl::in<cpp2::i64> _val)
    -> TGAImageType &
{
  _value = cpp2::unchecked_narrow<cpp2::u8>(_val);
  return *this;
}

inline CPP2_CONSTEXPR TGAImageType TGAImageType::NoImage{0};

inline CPP2_CONSTEXPR TGAImageType TGAImageType::UncompressedRgb{2};

[[nodiscard]] constexpr auto TGAImageType::get_raw_value() const & -> cpp2::u8
{
  return _value;
}

constexpr TGAImageType::TGAImageType() : _value{NoImage._value} {}

constexpr TGAImageType::TGAImageType(TGAImageType const &that)
    : _value{that._value}
{
}

constexpr auto TGAImageType::operator=(TGAImageType const &that)
    -> TGAImageType &
{
  _value = that._value;
  return *this;
}

constexpr TGAImageType::TGAImageType(TGAImageType &&that) noexcept
    : _value{std::move(that)._value}
{
}

constexpr auto TGAImageType::operator=(TGAImageType &&that) noexcept
    -> TGAImageType &
{
  _value = std::move(that)._value;
  return *this;
}

[[nodiscard]] auto TGAImageType::to_string_impl(
    cpp2::impl::in<std::string_view> prefix) const & -> std::string
{

  auto pref{cpp2::to_string(prefix)};
  if ((*this) == TGAImageType::NoImage) {
    return pref + "NoImage";
  }
  if ((*this) == TGAImageType::UncompressedRgb) {
    return cpp2::move(pref) + "UncompressedRgb";
  }
  return "invalid TGAImageType value";
}

[[nodiscard]] auto TGAImageType::to_string() const & -> std::string
{
  return to_string_impl("");
}

[[nodiscard]] auto TGAImageType::to_code() const & -> std::string
{
  return to_string_impl("TGAImageType::");
}

[[nodiscard]] auto TGAImageType::from_string(cpp2::impl::in<std::string_view> s)
    -> TGAImageType
{

  auto x{s};
  if ("NoImage" == x) {
    return TGAImageType::NoImage;
  } else {
    if ("UncompressedRgb" == cpp2::move(x)) {
      return TGAImageType::UncompressedRgb;
    }
  }
  CPP2_UFCS(report_violation)(
      cpp2::type_safety,
      CPP2_UFCS(c_str)(("can't convert string '" + cpp2::to_string(s) +
                        "' to enum of type TGAImageType")));
  return TGAImageType::NoImage;
}

[[nodiscard]] auto TGAImageType::from_code(cpp2::impl::in<std::string_view> s)
    -> TGAImageType
{
  std::string str{s};
  return from_string(
      cpp2::string_util::replace_all(cpp2::move(str), "TGAImageType::", ""));
}

TGAHeader::TGAHeader(cpp2::impl::in<cpp2::u16> width,
                     cpp2::impl::in<cpp2::u16> height)
    : imageWidth{width}, imageHeight{height}
{
}

[[nodiscard]] auto TGAHeader::getWidth() const & -> cpp2::u16
{
  return imageWidth;
}

[[nodiscard]] auto TGAHeader::getHeight() const & -> cpp2::u16
{
  return imageHeight;
}

TGAHeader::TGAHeader(TGAHeader const &that)
    : idLength{that.idLength}, ColourFMapType{that.ColourFMapType},
      imageType{that.imageType}, ColourFMapOrigin{that.ColourFMapOrigin},
      ColourFMapLength{that.ColourFMapLength},
      ColourFMapDepth{that.ColourFMapDepth}, imageXOrigin{that.imageXOrigin},
      imageYOrigin{that.imageYOrigin}, imageWidth{that.imageWidth},
      imageHeight{that.imageHeight}, imageBitsPP{that.imageBitsPP},
      imageDesc{that.imageDesc}
{
}

auto TGAHeader::operator=(TGAHeader const &that) -> TGAHeader &
{
  idLength = that.idLength;
  ColourFMapType = that.ColourFMapType;
  imageType = that.imageType;
  ColourFMapOrigin = that.ColourFMapOrigin;
  ColourFMapLength = that.ColourFMapLength;
  ColourFMapDepth = that.ColourFMapDepth;
  imageXOrigin = that.imageXOrigin;
  imageYOrigin = that.imageYOrigin;
  imageWidth = that.imageWidth;
  imageHeight = that.imageHeight;
  imageBitsPP = that.imageBitsPP;
  imageDesc = that.imageDesc;
  return *this;
}

TGAHeader::TGAHeader(TGAHeader &&that) noexcept
    : idLength{std::move(that).idLength},
      ColourFMapType{std::move(that).ColourFMapType},
      imageType{std::move(that).imageType},
      ColourFMapOrigin{std::move(that).ColourFMapOrigin},
      ColourFMapLength{std::move(that).ColourFMapLength},
      ColourFMapDepth{std::move(that).ColourFMapDepth},
      imageXOrigin{std::move(that).imageXOrigin},
      imageYOrigin{std::move(that).imageYOrigin},
      imageWidth{std::move(that).imageWidth},
      imageHeight{std::move(that).imageHeight},
      imageBitsPP{std::move(that).imageBitsPP},
      imageDesc{std::move(that).imageDesc}
{
}

auto TGAHeader::operator=(TGAHeader &&that) noexcept -> TGAHeader &
{
  idLength = std::move(that).idLength;
  ColourFMapType = std::move(that).ColourFMapType;
  imageType = std::move(that).imageType;
  ColourFMapOrigin = std::move(that).ColourFMapOrigin;
  ColourFMapLength = std::move(that).ColourFMapLength;
  ColourFMapDepth = std::move(that).ColourFMapDepth;
  imageXOrigin = std::move(that).imageXOrigin;
  imageYOrigin = std::move(that).imageYOrigin;
  imageWidth = std::move(that).imageWidth;
  imageHeight = std::move(that).imageHeight;
  imageBitsPP = std::move(that).imageBitsPP;
  imageDesc = std::move(that).imageDesc;
  return *this;
}

TGAHeader::TGAHeader() {}
} // namespace detail

[[nodiscard]] auto
WriteBufferAsTGA(cpp2::impl::in<IColourBufferPtr> image,
                 cpp2::impl::in<std::filesystem::path> filename) -> bool
{
  std::ofstream ofs{filename, std::ios::binary};
  if (CPP2_UFCS(fail)(ofs)) {
    return false;
  }

  // automatically close stream on scope exit
  OnScopeExit onExit{[_0 = (&ofs)]() mutable -> void {
    CPP2_UFCS(close)((*cpp2::impl::assert_not_null(_0)));
  }};

  // write out header
  detail::TGAHeader const fileHeader{
      CPP2_UFCS(getWidth)((*cpp2::impl::assert_not_null(image))),
      CPP2_UFCS(getHeight)((*cpp2::impl::assert_not_null(image)))};
  static_cast<void>(
      CPP2_UFCS(write)(ofs,
                       cpp2::unchecked_cast<char const *>(
                           cpp2::unchecked_cast<void const *>(&fileHeader)),
                       sizeof(fileHeader)));

  // and then each pixel, in BGR order
  for (auto const &y :
       cpp2::range(CPP2_UFCS(cpp2::u16)(0), CPP2_UFCS(getHeight)(fileHeader))) {
    for (auto const &x : cpp2::range(CPP2_UFCS(cpp2::u16)(0),
                                     CPP2_UFCS(getWidth)(fileHeader))) {

      auto pixelU8{CPP2_UFCS(tonemap)(
          CPP2_UFCS(get)((*cpp2::impl::assert_not_null(image)), x, y))};

      static_cast<void>(CPP2_UFCS(put)(ofs, pixelU8.b));
      static_cast<void>(CPP2_UFCS(put)(ofs, pixelU8.g));
      static_cast<void>(CPP2_UFCS(put)(ofs, cpp2::move(pixelU8).r));
    }
  }
  return true;
}
#endif
