#include "util/blog.h"
#include <execution>

// Generated by cppfront v0.8.2 build AA17:1543
#define CPP2_IMPORT_STD Yes
#define CPP2_NO_EXCEPTIONS Yes

#include "cpp2util.h"

class RayScene;

#include "geom/prims.h"
#include "geom/ray.h"
#include "geom/vec2.h"
#include "geom/vec3.h"

#include "image/buffer.h"
#include "image/tga.h"

#include "math/rng.h"

#include "proc/proctex.h"

// ---------------------------------------------------------------------------------------------------------------------
auto contractViolationHandler(char const *msg, std::source_location where)
    -> void;

// ---------------------------------------------------------------------------------------------------------------------
[[nodiscard]] auto main() -> int;

// ---------------------------------------------------------------------------------------------------------------------
// a container for primitives to trace rays against; just a big brute-force
// list, no subdivision system
class RayScene {

private:
  std::vector<std::unique_ptr<IIntersectable>> objects{};

  // bolt in a new primitive
public:
  template <typename T, typename... Args>
  auto addPrim(Args &&...args) & -> void;

  // fetch a unique_ptr* at the given index
public:
  [[nodiscard]] auto
  primAt(cpp2::impl::in<cpp2::u32> objectIndex) const & -> decltype(auto);

  // trace for any hit, no further data (eg. plain shadow rays) with an optional
  // distance limit
public:
  [[nodiscard]] auto
  hit(Ray const &ray, cpp2::impl::in<double> limit =
                          std::numeric_limits<double>::max()) const & -> bool;

  // trace to find nearest object; returns true and populates the nearestHit &
  // nearestObject if anything was found
public:
  [[nodiscard]] auto trace(Ray const &ray, Intersection &nearestHit,
                           cpp2::u32 &nearestObject) const & -> bool;

public:
  RayScene() = default;

public:
  RayScene(RayScene const &) =
      delete; /* No 'that' constructor, suppress copy */
public:
  auto operator=(RayScene const &) -> void = delete;
};

// ---------------------------------------------------------------------------------------------------------------------
// render a single scanline at [y] into the given image buffer
auto renderScan(cpp2::impl::in<cpp2::u16> y, RayScene const &scene,
                Camera const &renderCamera,
                cpp2::impl::in<IColourBufferPtr> image) -> void;

// ---------------------------------------------------------------------------------------------------------------------
[[nodiscard]] auto raytrace(std::filesystem::path &&outputPath) -> int;

auto contractViolationHandler(char const *msg, std::source_location where)
    -> void
{
  blog::error("Contract Violation | {}", CPP2_UFCS(function_name)(where));
  blog::error("{}({}) : {}", CPP2_UFCS(file_name)(where),
              CPP2_UFCS(line)(cpp2::move(where)), cpp2::move(msg));
  __debugbreak();
  exit(-1);
}

[[nodiscard]] auto main() -> int
{

  // plug in our custom error handlers
  CPP2_UFCS(set_handler)(cpp2::cpp2_default, &contractViolationHandler);
  CPP2_UFCS(set_handler)(cpp2::bounds_safety, &contractViolationHandler);

  // configure win terminal for better logging
  blog::configureTerminal();

  // attack your CPU cores and barf out a picture why don't we
  return raytrace("result.tga");
}

template <typename T, typename... Args>
auto RayScene::addPrim(Args &&...args) & -> void
{
  CPP2_UFCS(emplace_back)(objects, cpp2_new<T>(CPP2_FORWARD(args)...));
}

[[nodiscard]] auto RayScene::primAt(
    cpp2::impl::in<cpp2::u32> objectIndex) const & -> decltype(auto)
{
  return &CPP2_ASSERT_IN_BOUNDS(objects, objectIndex);
}

[[nodiscard]] auto RayScene::hit(Ray const &ray,
                                 cpp2::impl::in<double> limit) const & -> bool
{
  Intersection hit{};
  hit.query = IntersectionQuery::DistanceOnly; // tell prims to only bother
                                               // computing distance on hit

  for (auto const &obj : objects) {
    if (CPP2_UFCS(intersect)((*cpp2::impl::assert_not_null(obj)), ray, hit)) {
      if (cpp2::impl::cmp_less(hit.dist, limit)) {
        return true;
      }
    }
  }
  return false;
}

[[nodiscard]] auto RayScene::trace(Ray const &ray, Intersection &nearestHit,
                                   cpp2::u32 &nearestObject) const & -> bool
{

  nearestHit = {};
  nearestObject = -1;

  Intersection hit{};

  cpp2::u32 objectIndex{0u};
  for (auto const &obj : objects) {
    do {
      if (CPP2_UFCS(intersect)((*cpp2::impl::assert_not_null(obj)), ray, hit)) {
        if (cpp2::impl::cmp_less(hit.dist, nearestHit.dist)) {
          nearestHit = hit;
          nearestObject = objectIndex;
        }
      }
    } while (false);
    ++objectIndex;
  }
  return nearestObject != -1;
}

auto renderScan(cpp2::impl::in<cpp2::u16> y, RayScene const &scene,
                Camera const &renderCamera,
                cpp2::impl::in<IColourBufferPtr> image) -> void
{

  Intersection hit{};
  cpp2::u32 obj{};

  rng32 rng{};

  // pick a number of occlusion samples; increasing will smooth the ambient
  // shadowing but it increases the time spent per pixel
  auto constexpr occlusionSamples{64};
  auto constexpr occlusionDelta{
      1.0 /
      CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(1.0),
                           cpp2::unchecked_narrow<double>(occlusionSamples))};

  // how many sub-samples per-pixel
  auto constexpr perPixelSamples{32};
  auto constexpr perPixelDelta{
      1.0 /
      CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(1.0),
                           cpp2::unchecked_narrow<double>(perPixelSamples))};
  if (cpp2::cpp2_default.is_active() &&
      !(cpp2::impl::cmp_greater_eq(perPixelSamples, 1))) {
    cpp2::cpp2_default.report_violation("");
  }

  // walk the scanline
  for (auto const &x : cpp2::range(
           CPP2_UFCS(cpp2::u16)(0),
           CPP2_UFCS(getWidth)((*cpp2::impl::assert_not_null(image))))) {

    auto xD{cpp2::unchecked_narrow<double>(x)};
    auto yD{cpp2::unchecked_narrow<double>(y)};
    auto imageUV{
        CPP2_UFCS(getUVatXY)((*cpp2::impl::assert_not_null(image)), x, y)};

    ColourF outColour{};

    for (auto const &pps : cpp2::range(0, perPixelSamples)) {

      // undignified sampling window
      auto xDOff{-0.9 + (CPP2_UFCS(genGauss)(rng) * 1.8)};
      auto yDOff{-0.9 + (CPP2_UFCS(genGauss)(rng) * 1.8)};
      if (pps == 0) {
        xDOff = 0;
        yDOff = 0;
      }

      // generate a primary ray for this pixel
      auto cameraRay{CPP2_UFCS(generateRayAtPixelFrac)(
          renderCamera, xD + cpp2::move(xDOff), yD + cpp2::move(yDOff))};

      // go find the nearest thing in the scene
      if (CPP2_UFCS(trace)(scene, cameraRay, hit, obj)) {

        // create object-local rng using its primitive index
        rng32 objRng{obj + 100};

        // a shadow test position needs shifting a tiny fraction away from the
        // surface to avoid collision with the original object
        auto shadowTestPos{hit.pos + (hit.normal * 1e-5)};

        // goofy little ambient occlusion routine; cast N random shadow samples
        // out in a hemisphere aligned to the surface normal. we split the group
        // into testing for near-by objects (which darken more) and a general,
        // infinite test (which gives a nice soft fall-off)
        auto occlusion{1.0};
        for (auto const &os : cpp2::range(0, occlusionSamples)) {
          auto hemi{RandomHemisphere(hit.normal, rng)};
          Ray shadowRay{shadowTestPos, cpp2::move(hemi)};

          if (cpp2::impl::cmp_less(os, (occlusionSamples >> 2))) {
            if (CPP2_UFCS(hit)(scene, cpp2::move(shadowRay), 0.75)) {
              occlusion -= occlusionDelta * 1.5;
            }
          } else {
            if (CPP2_UFCS(hit)(scene, cpp2::move(shadowRay))) {
              occlusion -= occlusionDelta;
            }
          }
        }
        occlusion = std::max(occlusion, 0.0);

        auto ambientI{0.4};

        // -----------------------------------------------------------------------------------------------------
        // dream up some material properties
        auto diffuseI{1.0};
        auto specularI{2.0};
        auto texture{1.0};

        // choose some per-prim material fx
        if (hit.prim == IntersectionPrim::Sphere) {

          auto repeats{4.0};
          if (cpp2::impl::cmp_less_eq(CPP2_UFCS(genFloat)(objRng), 0.7)) {
            repeats += 4.0;
          }
          auto checker{proc::Checkerboard(hit.uv, cpp2::move(repeats))};
          texture -= cpp2::move(checker) * 0.15;

          // texture += proc::Voronoise( hit.uv * 32.0, 0.2, 0.2 ) * checker *
          // 0.2;
        }
        if (hit.prim == IntersectionPrim::Plane) {
          specularI = 0.0;

          auto impact{Vec3(-2.0, 0.5, -1.1) - hit.pos};
          auto impactDist{CPP2_UFCS(length)(cpp2::move(impact))};

          auto impactFalloff{1.0 - std::min(impactDist * 0.4, 1.0)};
          texture -= std::sin(cpp2::move(impactDist) *
                              (16.0 + (impactFalloff * 20.0))) *
                     (0.15 * impactFalloff);
        }

        // add a point light for some contrast
        auto lightDir{CPP2_UFCS(normalised)((Vec3(0.5, 3.0, -2.0) - hit.pos))};

        // diffuse contribution
        auto NdotL{Vec3::dot(hit.normal, lightDir)};
        auto diffuseIntensity{std::clamp(cpp2::move(NdotL), 0.0, 1.0) *
                              cpp2::move(diffuseI)};

        // specular
        auto H{CPP2_UFCS(normalised)(
            (cpp2::move(lightDir) + CPP2_UFCS(dir)(cpp2::move(cameraRay))))};
        auto NdotH{Vec3::dot(hit.normal, cpp2::move(H))};
        auto specularIntensity{
            std::pow(std::clamp(cpp2::move(NdotH), 0.0, 1.0), 4.0) *
            cpp2::move(specularI)};

        // smunch it together
        auto lighting{cpp2::move(ambientI) + cpp2::move(diffuseIntensity) +
                      cpp2::move(specularIntensity)};
        lighting *= cpp2::move(texture);
        lighting *= cpp2::move(occlusion);

        // monochrome == art
        outColour.r += (lighting * 1.15);
        outColour.g += (lighting * 1.14);
        outColour.b += (cpp2::move(lighting) * 1.13);

        static_cast<void>(cpp2::move(objRng));
      }
    }

    // -----------------------------------------------------------------------------------------------------
    // post-processing stage

    // add alternate-scan darkening/brightening
    auto postprocess{1.1};
    if (y % 2 == 0) {
      postprocess = 0.75;
    }

    // add vignette
    auto vigUV{Vec2(1.0 - imageUV.y, 1.0 - imageUV.x) * imageUV};
    auto vig{vigUV.x * vigUV.y * 15.0};
    vig = std::pow(vig, 0.25);
    postprocess *= cpp2::move(vig);

    // -----------------------------------------------------------------------------------------------------
    // final out to buffer

    outColour.r *= perPixelDelta * postprocess;
    outColour.g *= perPixelDelta * postprocess;
    outColour.b *= perPixelDelta * cpp2::move(postprocess);
    CPP2_UFCS(set)((*cpp2::impl::assert_not_null(image)), x, y,
                   cpp2::move(outColour));
  }
}

[[nodiscard]] auto raytrace(std::filesystem::path &&outputPath) -> int
{

  blog::debug("WARNING! this is a debug build, it will be SLOW to render!");

  blog::app("allocating framebuffer ...");
  auto framebuffer{
      CPP2_UFCS_TEMPLATE(cpp2_new<BufferRGB<900, 480>>)(cpp2::shared)};

  // deterministic RNG for scene setup
  rng32 sceneRng{100};

  // cook up something to render
  RayScene scene{};
  CPP2_UFCS_TEMPLATE(addPrim<Sphere>)(scene, Vec3(0.0, 0.5, 0.1), 0.5,
                                      RandomNormal(sceneRng));
  CPP2_UFCS_TEMPLATE(addPrim<Sphere>)(scene, Vec3(-1.2, 0.8, -0.3), 0.5,
                                      RandomNormal(sceneRng));
  CPP2_UFCS_TEMPLATE(addPrim<Sphere>)(scene, Vec3(-1.8, 0.5, -1.1), 0.3,
                                      RandomNormal(sceneRng));
  CPP2_UFCS_TEMPLATE(addPrim<Sphere>)(scene, Vec3(-1.2, 0.3, -2.1), 0.2,
                                      RandomNormal(sceneRng));
  CPP2_UFCS_TEMPLATE(addPrim<Sphere>)(scene, Vec3(-0.4, -0.4, -1.4), 0.8,
                                      RandomNormal(sceneRng));
  CPP2_UFCS_TEMPLATE(addPrim<Plane>)(scene, Vec3(0.0, 1.0, 0.0), 0.0);
  CPP2_UFCS_TEMPLATE(addPrim<Plane>)(scene, Vec3(1.0, 0.0, 0.0), -2.0);

  static_cast<void>(cpp2::move(sceneRng));

  // .. and a place to render it from
  Camera renderCamera{
      Vec3(1.0, 1.5, -3.5), Vec3(-2.0, 0.3, 0.0),
      CPP2_UFCS(getWidth)((*cpp2::impl::assert_not_null(framebuffer))),
      CPP2_UFCS(getHeight)((*cpp2::impl::assert_not_null(framebuffer))),
      Angle::fromDegrees(70.0)};

  // multithread dispatch of each scanline using std::execution
  {
    ScopedTimer renderTimer{"rendering"};

    auto scanlinesToDo{
        CPP2_UFCS(getHeight)((*cpp2::impl::assert_not_null(framebuffer)))};
    std::ranges::iota_view scanlinesRange{
        CPP2_UFCS(cpp2::u16)(0), scanlinesToDo}; // range to iterate of 0..y
    std::atomic_uint32_t scanlinesDone{};

    auto scanlinesPct{
        1.0 /
        CPP2_ASSERT_NOT_ZERO(
            CPP2_TYPEOF(1.0),
            cpp2::unchecked_narrow<double>(cpp2::move(
                scanlinesToDo)))}; // used to publish completion percentage

    std::for_each(
        std::execution::par_unseq, CPP2_UFCS(begin)(scanlinesRange),
        CPP2_UFCS(end)(cpp2::move(scanlinesRange)),
        [_0 = (&scene), _1 = cpp2::move(renderCamera), _2 = framebuffer,
         _3 = (&scanlinesDone),
         _4 = cpp2::move(scanlinesPct)](auto const &y) mutable -> void {
          renderScan(y, *cpp2::impl::assert_not_null(_0), _1, _2);

          auto scansComplete{++*cpp2::impl::assert_not_null(_3)};
          if ((scansComplete % 20) == 0) {
            blog::app(" -- tracing : {:3}%",
                      std::round(cpp2::unchecked_narrow<double>(
                                     cpp2::move(scansComplete)) *
                                 _4 * 100.0));
          }
        });
  }

  if (WriteBufferAsTGA(cpp2::move(framebuffer), outputPath) == false) {
    blog::error("failed to write out result '{}'",
                CPP2_UFCS(string)(cpp2::move(outputPath)));
  } else {
    blog::app("complete!");
  }

  return 0;
}
