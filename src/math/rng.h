#include <intrin.h>

// Generated by cppfront v0.8.2 build AA17:1543
#ifndef RNG_H_CPP2
#define RNG_H_CPP2

#define CPP2_IMPORT_STD Yes
#define CPP2_NO_EXCEPTIONS Yes

#include "cpp2util.h"

class rng32;

// a dinky random number generator
class rng32 {

private:
  static const cpp2::u32 mask; // to clip out u32 chunks from u64 source

  // deterministic construct with specific seed
public:
  rng32(cpp2::impl::in<cpp2::u32> newseed);

public:
  auto operator=(cpp2::impl::in<cpp2::u32> newseed) -> rng32 &;

  // non-deterministic construct by default with a spin of the cpu timestamp as
  // the seed
public:
  explicit rng32();

  // reset to a new given seed value
public:
  auto reseed(cpp2::impl::in<cpp2::u32> newseed) & -> void;

  // generate a new random u32 using Marsaglia's Multiply-with-carry (MWCG)
  // https://web.archive.org/web/20100409203822/http://cliodhna.cop.uop.edu/~hetrick/na_faq.html
public:
  [[nodiscard]] auto genU32() & -> cpp2::u32;

  // generate a float in the range 0..1
public:
  [[nodiscard]] auto genFloat() & -> float;

  // sum-of-uniforms / central limit bell curve
public:
  [[nodiscard]] auto genGauss() & -> float;

private:
  cpp2::u32 m_seed0{};

private:
  cpp2::u32 m_seed1{};

public:
  rng32(rng32 const &that);

public:
  auto operator=(rng32 const &that) -> rng32 &;

public:
  rng32(rng32 &&that) noexcept;

public:
  auto operator=(rng32 &&that) noexcept -> rng32 &;
};

inline CPP2_CONSTEXPR cpp2::u32 rng32::mask{
    std::numeric_limits<cpp2::u32>::max()};

rng32::rng32(cpp2::impl::in<cpp2::u32> newseed) { reseed(newseed); }

auto rng32::operator=(cpp2::impl::in<cpp2::u32> newseed) -> rng32 &
{
  m_seed0 = {};
  m_seed1 = {};
  reseed(newseed);
  return *this;
}

rng32::rng32()
{
  cpp2::u64 value{__rdtsc()};
  value ^= value >> 33;
  value *= 0x64dd81482cbd31d7UL;
  value ^= value >> 33;
  value *= 0xe36aa5c613612997UL;
  value ^= value >> 33;

  m_seed0 = cpp2::unchecked_narrow<cpp2::u32>(value & mask);
  m_seed1 = cpp2::unchecked_narrow<cpp2::u32>((cpp2::move(value) >> 32) & mask);
}

auto rng32::reseed(cpp2::impl::in<cpp2::u32> newseed) & -> void
{
  m_seed0 = newseed + !(newseed);
  m_seed1 = ((newseed << 16) | (newseed >> 16)) ^ newseed;
}

[[nodiscard]] auto rng32::genU32() & -> cpp2::u32
{

  // chosen from example values in original MWCG post (linked above)
  cpp2::u64 constexpr multiplier{2051013963};

  cpp2::u64 const temp{multiplier * m_seed0 + m_seed1};

  m_seed0 = cpp2::unchecked_narrow<cpp2::u32>(temp & mask);
  m_seed1 = cpp2::unchecked_narrow<cpp2::u32>((cpp2::move(temp) >> 32) & mask);

  return m_seed0;
}

[[nodiscard]] auto rng32::genFloat() & -> float
{
  // mask lower 23 bits, multiply by 1/2**23.
  cpp2::i32 const value{std::bit_cast<cpp2::i32>(genU32())};
  return (cpp2::move(value) & ((1 << 23) - 1)) * 0.00000011920928955078125f;
}

[[nodiscard]] auto rng32::genGauss() & -> float
{
  auto r0{genFloat()};
  auto r1{genFloat()};
  auto r2{genFloat()};
  auto r3{genFloat()};
  return (cpp2::move(r0) + cpp2::move(r1) + cpp2::move(r2) + cpp2::move(r3)) *
         0.25f;
}

rng32::rng32(rng32 const &that) : m_seed0{that.m_seed0}, m_seed1{that.m_seed1}
{
}

auto rng32::operator=(rng32 const &that) -> rng32 &
{
  m_seed0 = that.m_seed0;
  m_seed1 = that.m_seed1;
  return *this;
}

rng32::rng32(rng32 &&that) noexcept
    : m_seed0{std::move(that).m_seed0}, m_seed1{std::move(that).m_seed1}
{
}

auto rng32::operator=(rng32 &&that) noexcept -> rng32 &
{
  m_seed0 = std::move(that).m_seed0;
  m_seed1 = std::move(that).m_seed1;
  return *this;
}
#endif
