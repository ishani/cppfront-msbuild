 #include <intrin.h>

// a dinky random number generator
rng32: @basic_value type = {

	private mask: u32 == std::numeric_limits<u32>::max();	// to clip out u32 chunks from u64 source

	// deterministic construct with specific seed
	operator=: (out this, newseed:u32) = reseed(newseed);
	
	// non-deterministic construct by default with a spin of the cpu timestamp as the seed
	operator=: (out this) = {
		value: u64 = __rdtsc();
		value ^= value >> 33;
		value *= 0x64dd81482cbd31d7UL;
		value ^= value >> 33;
		value *= 0xe36aa5c613612997UL;
		value ^= value >> 33;

		m_seed0 = unchecked_narrow<u32>( value & mask );
		m_seed1 = unchecked_narrow<u32>( (value >> 32) & mask );
	}

	// reset to a new given seed value
	reseed: (inout this, newseed:u32) = {
		m_seed0 = newseed + !newseed;
		m_seed1 = ((newseed << 16) | (newseed >> 16)) ^ newseed;
	}

	// generate a new random u32 using Marsaglia's Multiply-with-carry (MWCG)
	// https://web.archive.org/web/20100409203822/http://cliodhna.cop.uop.edu/~hetrick/na_faq.html
	genU32: (inout this) -> u32 = {

		// chosen from example values in original MWCG post (linked above)
		multiplier: u64 == 2051013963;

		temp: const u64 = multiplier * m_seed0 + m_seed1;

		m_seed0 = unchecked_narrow<u32>( temp & mask );
		m_seed1 = unchecked_narrow<u32>( (temp >> 32) & mask );

		return m_seed0;
	}

	// generate a float in the range 0..1
	genFloat: (inout this) -> float = {
		// mask lower 23 bits, multiply by 1/2**23.
		value: const i32 = std::bit_cast<i32>(genU32());
		return (value & ((1 << 23) - 1)) * 0.00000011920928955078125f;
	}

	// sum-of-uniforms / central limit bell curve
	genGauss: (inout this) -> float = {
		r0: = genFloat();
		r1: = genFloat();
		r2: = genFloat();
		r3: = genFloat();
		return (r0 + r1 + r2 + r3) * 0.25f;
	}

	private m_seed0: u32 = ();
	private m_seed1: u32 = ();
}
