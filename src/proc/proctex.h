
// Generated by cppfront v0.8.2 build AA17:1543
#ifndef PROCTEX_H_CPP2
#define PROCTEX_H_CPP2

#define CPP2_IMPORT_STD Yes
#define CPP2_NO_EXCEPTIONS Yes

#include "cpp2util.h"

namespace proc {

}

// glsl-style mod() that handles -ve values
[[nodiscard]] constexpr auto mod(cpp2::impl::in<double> a,
                                 cpp2::impl::in<double> b) -> double;

[[nodiscard]] auto frac(cpp2::impl::in<double> val) -> double;

[[nodiscard]] auto smoothstep(cpp2::impl::in<double> edge0,
                              cpp2::impl::in<double> edge1,
                              cpp2::impl::in<double> x) -> double;

[[nodiscard]] auto hash3(Vec2 const &p) -> Vec3;

// some simple procedural texture functions, given some input UV coordinates
namespace proc {

[[nodiscard]] auto Checkerboard(Vec2 const &uv,
                                cpp2::impl::in<double> checkSize) -> double;

// https://www.shadertoy.com/view/Xd23Dh
[[nodiscard]] auto Voronoise(Vec2 const &p, cpp2::impl::in<double> u,
                             cpp2::impl::in<double> v) -> double;

} // namespace proc

[[nodiscard]] constexpr auto mod(cpp2::impl::in<double> a,
                                 cpp2::impl::in<double> b) -> double
{
  if (cpp2::impl::cmp_greater_eq(a, 0)) {
    return std::fmod(a, b);
  } else {
    auto ret{std::fmod(-a, b)};
    if (ret == 0) {
      return ret;
    } else {
      return b - cpp2::move(ret);
    }
  }
}

[[nodiscard]] auto frac(cpp2::impl::in<double> val) -> double
{
  return val - std::trunc(val);
}

[[nodiscard]] auto smoothstep(cpp2::impl::in<double> edge0,
                              cpp2::impl::in<double> edge1,
                              cpp2::impl::in<double> x) -> double
{
  // scale, and clamp x to 0..1 range
  auto v{std::clamp((x - edge0) / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF((x - edge0)),
                                                       (edge1 - edge0)),
                    0.0, 1.0)};

  return v * v * (3.0f - 2.0f * v);
}

[[nodiscard]] auto hash3(Vec2 const &p) -> Vec3
{

  auto q{Vec3(Vec2::dot(p, Vec2(127.1, 311.7)),
              Vec2::dot(p, Vec2(269.5, 183.3)),
              Vec2::dot(p, Vec2(419.2, 371.9)))};

  auto x{frac(std::sin(q.x) * 43758.5453)};
  auto y{frac(std::sin(q.y) * 43758.5453)};
  auto z{frac(std::sin(cpp2::move(q).z) * 43758.5453)};

  return Vec3(cpp2::move(x), cpp2::move(y), cpp2::move(z));
}

namespace proc {

[[nodiscard]] auto Checkerboard(Vec2 const &uv,
                                cpp2::impl::in<double> checkSize) -> double
{
  auto fmodResult{
      mod(std::floor(checkSize * uv.x) + floor(checkSize * uv.y), 2.0)};
  if (cpp2::impl::cmp_greater(cpp2::move(fmodResult), 0)) {
    return 1.0;
  }
  return 0.0;
}

[[nodiscard]] auto Voronoise(Vec2 const &p, cpp2::impl::in<double> u,
                             cpp2::impl::in<double> v) -> double
{
  double k{1.0 + 63.0 * std::pow(1.0 - v, 6.0)};

  auto i{Vec2(std::floor(p.x), std::floor(p.y))};
  auto f{Vec2(frac(p.x), frac(p.y))};

  auto a{Vec2(0.0, 0.0)};

  for (auto const &y : cpp2::range((-2), 2)) {
    for (auto const &x : cpp2::range((-2), 2)) {
      auto g{Vec2(cpp2::unchecked_narrow<double>(x),
                  cpp2::unchecked_narrow<double>(y))};
      auto o{hash3(i + g) * Vec3(u, u, 1.0)};

      auto d{cpp2::move(g) - f + Vec2(o.x, o.y)};

      auto w{std::pow(
          1.0 - smoothstep(0.0, 1.414, CPP2_UFCS(length)(cpp2::move(d))), k)};
      a += Vec2(cpp2::move(o).z * w, cpp2::move(w));
    }
  }
  if (a.y == 0.0) {
    return 0.0;
  }
  return std::clamp(a.x / CPP2_ASSERT_NOT_ZERO(CPP2_TYPEOF(a.x), a.y), 0.0,
                    1.0);
}

} // namespace proc

#endif
